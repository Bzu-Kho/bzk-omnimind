<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üååüîÆ Mapa Interactivo del Universo Omnisciente üîÆüåå</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 35%, #0f0f23 100%);
            color: #00ffff;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite alternate;
        }
        
        @keyframes twinkle {
            0% { opacity: 0.3; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.2); }
        }
        
        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 255, 255, 0.1);
            border-bottom: 2px solid #00ffff;
            position: relative;
            z-index: 10;
        }
        
        .header h1 {
            font-size: 2.5em;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 20px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 40px #00ffff; }
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.8;
        }
        
        .container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
            padding: 20px;
            min-height: calc(100vh - 120px);
            position: relative;
            z-index: 10;
        }
        
        .panel {
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        .universe-view {
            position: relative;
            background: black;
            border-radius: 10px;
            overflow: hidden;
            min-height: 600px;
        }
        
        .universe-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .universe-3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }
        
        .universe-3d.active {
            display: block;
        }
        
        .controls h3, .info h3 {
            color: #00ffff;
            border-bottom: 1px solid #00ffff;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        .control-group select, 
        .control-group input[type="range"] {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 5px;
            border-radius: 5px;
        }
        
        .control-group input[type="range"] {
            height: 25px;
        }
        
        .btn {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border: none;
            color: black;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .cosmic-stats {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 3px solid #00ffff;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        
        .stat-value {
            color: #ffff00;
            font-weight: bold;
        }
        
        .dimensional-indicator {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ffff00;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .coordinates {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 1px solid #00ff00;
        }
        
        .nearby-objects {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ff00ff;
        }
        
        .object-item {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
            border-left: 3px solid;
        }
        
        .galaxy { border-left-color: #00ffff; }
        .civilization { border-left-color: #ffff00; }
        .portal { border-left-color: #ff00ff; }
        .blackhole { border-left-color: #ff0000; }
        
        .omniscient-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 0, 0.9);
            color: black;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 100;
        }
        
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
            
            .panel {
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Fondo de estrellas -->
    <div class="stars" id="stars"></div>
    
    <!-- Encabezado -->
    <header class="header">
        <h1>üååüîÆ MAPA INTERACTIVO DEL UNIVERSO üîÆüåå</h1>
        <div class="subtitle">
            üß† Conocimiento Universal: 1,064.84% | üåü Reality Manipulation: ACTIVA | üîÆ Fase: COSMIC_INTEGRATION
        </div>
    </header>
    
    <!-- Contenedor principal -->
    <div class="container">
        <!-- Panel de controles -->
        <div class="panel controls">
            <h3>üéÆ CONTROLES C√ìSMICOS</h3>
            
            <div class="control-group">
                <label for="scale">üìè Escala de Observaci√≥n:</label>
                <select id="scale">
                    <option value="observable_universe">Universo Observable</option>
                    <option value="local_group">Grupo Local</option>
                    <option value="milky_way">V√≠a L√°ctea</option>
                    <option value="solar_system">Sistema Solar</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="dimension">üåÄ Dimensi√≥n: <span id="dimension-value">0</span></label>
                <input type="range" id="dimension" min="0" max="10" value="0">
            </div>
            
            <div class="control-group">
                <label for="zoom">üîç Zoom: <span id="zoom-value">1.0</span>x</label>
                <input type="range" id="zoom" min="0.1" max="100" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <label for="view-mode">üëÅÔ∏è Modo de Vista:</label>
                <button id="toggle-3d" class="cosmic-button">üåå Vista 3D</button>
            </div>
            
            <div class="dimensional-indicator">
                <strong>Dimensi√≥n Actual: <span id="current-dimension">0</span></strong><br>
                <small id="dimension-description">Universo Observable (3D + Tiempo)</small>
            </div>
            
            <button class="btn" onclick="autoTravel()">üöÄ Viaje Autom√°tico</button>
            <button class="btn" onclick="cosmicAnalysis()">üìä An√°lisis C√≥smico</button>
            <button class="btn" onclick="omniscientView()">üîÆ Vista Omnisciente</button>
            <button class="btn" onclick="resetView()">üîÑ Reiniciar Vista</button>
        </div>
        
        <!-- Vista principal del universo -->
        <div class="panel universe-view">
            <div class="omniscient-overlay">
                üîÆ OMNISCIENCE ACTIVA
            </div>
            <canvas class="universe-canvas" id="universe-canvas"></canvas>
            <div id="universe-3d" class="universe-3d"></div>
        </div>
        
        <!-- Panel de informaci√≥n -->
        <div class="panel info">
            <h3>üìä INFORMACI√ìN C√ìSMICA</h3>
            
            <div class="cosmic-stats">
                <h4>üåå Par√°metros Universales</h4>
                <div class="stat-item">
                    <span>Materia Oscura:</span>
                    <span class="stat-value">25.9%</span>
                </div>
                <div class="stat-item">
                    <span>Energ√≠a Oscura:</span>
                    <span class="stat-value">69.1%</span>
                </div>
                <div class="stat-item">
                    <span>Materia Ordinaria:</span>
                    <span class="stat-value">5.0%</span>
                </div>
                <div class="stat-item">
                    <span>Edad del Universo:</span>
                    <span class="stat-value">13.8 Ga</span>
                </div>
                <div class="stat-item">
                    <span>Di√°metro Observable:</span>
                    <span class="stat-value">93 Gly</span>
                </div>
            </div>
            
            <div class="coordinates" id="coordinates">
                üìç Posici√≥n Actual:<br>
                X: 0.00e+00 ly<br>
                Y: 0.00e+00 ly<br>
                Z: 0.00e+00 ly
            </div>
            
            <h4>üéØ Objetos Cercanos</h4>
            <div class="nearby-objects" id="nearby-objects">
                <div class="object-item galaxy">
                    üåå V√≠a L√°ctea<br>
                    <small>Distancia: 0 ly | Tipo: Spiral</small>
                </div>
                <div class="object-item civilization">
                    üõ∏ Civilizaci√≥n Local<br>
                    <small>Tipo: Type_0 | Desarrollo: 0.7%</small>
                </div>
                <div class="object-item portal">
                    üåÄ Portal Dimensional<br>
                    <small>Estabilidad: 45% | Dimensi√≥n: 0‚Üí3</small>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Variables globales
        let canvas, ctx;
        let scene, camera, renderer, controls;
        let is3DMode = false;
        let universeObjects3D = {
            galaxies: [],
            civilizations: [],
            portals: [],
            blackHoles: []
        };
        let universeData = {
            galaxies: [],
            civilizations: [],
            portals: [],
            blackHoles: [],
            wormholes: []
        };
        let currentPosition = [0, 0, 0];
        let currentDimension = 0;
        let currentScale = 'observable_universe';
        let zoomLevel = 1.0;
        let animationId;
        
        // Conocimiento omnisciente
        const cosmicKnowledge = {
            darkMatter: 0.259,
            darkEnergy: 0.691,
            ordinaryMatter: 0.050,
            hubbleConstant: 70.0,
            cosmicAge: 13.8e9,
            observableDiameter: 93e9,
            multiverseLayers: 11,
            galacticCivilizations: 847
        };
        
        // Frecuencias Anunaki
        const anunakiFrequencies = [396, 417, 528, 639, 741, 852, 963];
        
        // Inicializaci√≥n
        window.onload = function() {
            initializeStars();
            initializeCanvas();
            initialize3D();
            generateUniverseData();
            setupEventListeners();
            startAnimation();
            updateInfo();
        };
        
        function initializeStars() {
            const starsContainer = document.getElementById('stars');
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = Math.random() * 3 + 1 + 'px';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }
        
        function initializeCanvas() {
            canvas = document.getElementById('universe-canvas');
            ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }
        
        function initialize3D() {
            // Crear escena 3D
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Configurar c√°mara
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            // Configurar renderer con optimizaciones
            const container = document.getElementById('universe-3d');
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar pixel ratio para rendimiento
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            
            // Optimizaciones de rendering
            renderer.shadowMap.enabled = false; // Deshabilitamos sombras para mejor rendimiento
            renderer.physicallyCorrectLights = false;
            
            container.appendChild(renderer.domElement);
            
            // Configurar controles
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI;
            controls.enablePan = true;
            controls.enableZoom = true;
            controls.enableRotate = true;
            
            // Configuraci√≥n de sensibilidad
            controls.rotateSpeed = 0.5;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            
            // Agregar luces optimizadas
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // Crear cubo c√≥smico contenedor optimizado
            const cubeGeometry = new THREE.BoxGeometry(10, 10, 10);
            const cubeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.15
            });
            const cosmicCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            scene.add(cosmicCube);
            
            // Habilitar frustum culling autom√°tico
            scene.autoUpdate = true;
            
            // Manejar redimensionamiento
            window.addEventListener('resize', () => {
                const container = document.getElementById('universe-3d');
                camera.aspect = container.offsetWidth / container.offsetHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.offsetWidth, container.offsetHeight);
            });
            
            console.log('‚úÖ Sistema 3D optimizado inicializado');
        }
        
        function generateUniverseData() {
            console.log('üåå Generando datos del universo con conocimiento omnisciente...');
            
            // Generar galaxias
            for (let i = 0; i < 1000; i++) {
                universeData.galaxies.push({
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2,
                    z: (Math.random() - 0.5) * 2,
                    type: ['Spiral', 'Elliptical', 'Irregular', 'Dwarf'][Math.floor(Math.random() * 4)],
                    mass: Math.random() * 1e14,
                    age: Math.random() * 13.8e9,
                    luminosity: Math.random() * 1e12,
                    civilizationProbability: Math.random()
                });
            }
            
            // Generar civilizaciones
            for (let i = 0; i < cosmicKnowledge.galacticCivilizations; i++) {
                const kardashevTypes = ['Type_0', 'Type_I', 'Type_II', 'Type_III', 'Type_IV', 'Type_V', 'Type_Omega'];
                universeData.civilizations.push({
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2,
                    z: (Math.random() - 0.5) * 2,
                    name: `Civilization_${i + 1}`,
                    kardashevType: kardashevTypes[Math.floor(Math.random() * kardashevTypes.length)],
                    technologyLevel: Math.random() * 100,
                    dimensionalTravel: Math.random() < 0.1,
                    realityEngineering: Math.random() < 0.01,
                    anunakiRelated: Math.random() < 0.02,
                    peaceIndex: Math.random() * 10
                });
            }
            
            // Generar portales dimensionales
            for (let dim = 0; dim < cosmicKnowledge.multiverseLayers; dim++) {
                for (let i = 0; i < 20; i++) {
                    universeData.portals.push({
                        x: (Math.random() - 0.5) * 2,
                        y: (Math.random() - 0.5) * 2,
                        z: (Math.random() - 0.5) * 2,
                        sourceDimension: dim,
                        targetDimension: Math.floor(Math.random() * 11),
                        stability: Math.random(),
                        anunakiTechnology: Math.random() < 0.08
                    });
                }
            }
            
            // Generar agujeros negros
            for (let i = 0; i < 500; i++) {
                universeData.blackHoles.push({
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2,
                    z: (Math.random() - 0.5) * 2,
                    type: Math.random() < 0.1 ? 'supermassive' : 'stellar',
                    mass: Math.random() < 0.1 ? Math.random() * 1e10 : Math.random() * 50,
                    dimensionalGateway: Math.random() < 0.01
                });
            }
            
            console.log('‚úÖ Datos del universo generados con √©xito');
            create3DObjects();
        }
        
        function create3DObjects() {
            console.log('üåå Creando objetos 3D optimizados...');
            
            // Crear campo de estrellas de fondo
            createStarField();
            
            // Crear galaxias 3D con LOD y diferentes geometr√≠as seg√∫n el tipo
            universeData.galaxies.forEach((galaxy, index) => {
                if (index < 300) { // Aumentamos un poco el l√≠mite con LOD
                    const lodGroup = new THREE.Group();
                    const colors = {
                        'Spiral': 0x00ffff,
                        'Elliptical': 0xffff00,
                        'Irregular': 0xff00ff,
                        'Dwarf': 0x00ff00
                    };
                    
                    // Nivel de detalle alto (cerca)
                    let highGeometry, lowGeometry, material;
                    switch (galaxy.type) {
                        case 'Spiral':
                            highGeometry = new THREE.CylinderGeometry(0.1, 0.05, 0.02, 12);
                            lowGeometry = new THREE.CylinderGeometry(0.1, 0.05, 0.02, 6);
                            break;
                        case 'Elliptical':
                            highGeometry = new THREE.SphereGeometry(0.08, 16, 12);
                            lowGeometry = new THREE.SphereGeometry(0.08, 8, 6);
                            break;
                        case 'Irregular':
                            highGeometry = new THREE.DodecahedronGeometry(0.06);
                            lowGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.08);
                            break;
                        default: // Dwarf
                            highGeometry = new THREE.SphereGeometry(0.04, 12, 8);
                            lowGeometry = new THREE.SphereGeometry(0.04, 6, 4);
                    }
                    
                    material = new THREE.MeshBasicMaterial({ 
                        color: colors[galaxy.type] || 0xffffff,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const highDetailMesh = new THREE.Mesh(highGeometry, material);
                    const lowDetailMesh = new THREE.Mesh(lowGeometry, material);
                    
                    // Configurar LOD
                    const lod = new THREE.LOD();
                    lod.addLevel(highDetailMesh, 0);   // Distancia 0-5
                    lod.addLevel(lowDetailMesh, 5);    // Distancia 5+
                    
                    lod.position.set(galaxy.x * 5, galaxy.y * 5, galaxy.z * 5);
                    lod.userData = { type: 'galaxy', data: galaxy };
                    
                    // A√±adir glow effect solo para objetos cercanos
                    if (index < 100) { // Limitar glow para rendimiento
                        const glowGeometry = new THREE.SphereGeometry(0.15, 8, 6);
                        const glowMaterial = new THREE.MeshBasicMaterial({
                            color: colors[galaxy.type],
                            transparent: true,
                            opacity: 0.1,
                            blending: THREE.AdditiveBlending
                        });
                        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                        highDetailMesh.add(glow);
                    }
                    
                    scene.add(lod);
                    universeObjects3D.galaxies.push(lod);
                }
            });
            
            // Crear civilizaciones 3D con LOD
            universeData.civilizations.forEach((civ, index) => {
                if (index < 80) { // Optimizado para rendimiento
                    const kardashevColors = {
                        'Type_0': 0x808080,
                        'Type_I': 0x00ff00,
                        'Type_II': 0xffff00,
                        'Type_III': 0xff8000,
                        'Type_IV': 0xff0080,
                        'Type_V': 0x8000ff,
                        'Type_Omega': 0xffffff
                    };
                    
                    // Crear LOD para civilizaciones
                    const lod = new THREE.LOD();
                    
                    // Detalle alto
                    const highDetailGroup = new THREE.Group();
                    const mainGeometry = new THREE.ConeGeometry(0.03, 0.1, 8);
                    const mainMaterial = new THREE.MeshBasicMaterial({ 
                        color: kardashevColors[civ.kardashevType] || 0xffffff
                    });
                    const mainMesh = new THREE.Mesh(mainGeometry, mainMaterial);
                    highDetailGroup.add(mainMesh);
                    
                    // Anillos de energ√≠a solo para civilizaciones avanzadas y en detalle alto
                    if ((civ.kardashevType.includes('Type_IV') || civ.kardashevType.includes('Type_V') || civ.kardashevType.includes('Omega')) && index < 30) {
                        for (let i = 0; i < 2; i++) { // Reducido de 3 a 2 anillos
                            const ringGeometry = new THREE.RingGeometry(0.08 + i * 0.03, 0.09 + i * 0.03, 12);
                            const ringMaterial = new THREE.MeshBasicMaterial({
                                color: kardashevColors[civ.kardashevType],
                                transparent: true,
                                opacity: 0.6 - i * 0.2,
                                side: THREE.DoubleSide
                            });
                            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                            ring.rotation.x = Math.PI / 2;
                            ring.rotation.z = i * Math.PI / 3;
                            highDetailGroup.add(ring);
                        }
                    }
                    
                    // Detalle bajo
                    const lowDetailGeometry = new THREE.BoxGeometry(0.04, 0.04, 0.04);
                    const lowDetailMaterial = new THREE.MeshBasicMaterial({ 
                        color: kardashevColors[civ.kardashevType] || 0xffffff
                    });
                    const lowDetailMesh = new THREE.Mesh(lowDetailGeometry, lowDetailMaterial);
                    
                    lod.addLevel(highDetailGroup, 0);
                    lod.addLevel(lowDetailMesh, 3);
                    
                    lod.position.set(civ.x * 5, civ.y * 5, civ.z * 5);
                    lod.userData = { type: 'civilization', data: civ };
                    
                    scene.add(lod);
                    universeObjects3D.civilizations.push(lod);
                }
            });
            
            // Crear portales 3D con LOD
            universeData.portals.forEach((portal, index) => {
                if (index < 50) { // Optimizado
                    const lod = new THREE.LOD();
                    
                    // Detalle alto
                    const highDetailGroup = new THREE.Group();
                    
                    const geometry = new THREE.OctahedronGeometry(0.08);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: portal.anunakiTechnology ? 0xff00ff : 0x00ffff,
                        transparent: true,
                        opacity: portal.stability * 0.8,
                        wireframe: true
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    highDetailGroup.add(mesh);
                    
                    // Efecto de v√≥rtice solo en detalle alto
                    const vortexGeometry = new THREE.RingGeometry(0.05, 0.15, 16);
                    const vortexMaterial = new THREE.MeshBasicMaterial({
                        color: portal.anunakiTechnology ? 0xff00ff : 0x00ffff,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    });
                    const vortex = new THREE.Mesh(vortexGeometry, vortexMaterial);
                    highDetailGroup.add(vortex);
                    
                    // Menos part√≠culas orbitales para rendimiento
                    for (let i = 0; i < 4; i++) { // Reducido de 8 a 4
                        const particleGeometry = new THREE.SphereGeometry(0.01, 4, 4);
                        const particleMaterial = new THREE.MeshBasicMaterial({
                            color: portal.anunakiTechnology ? 0xff00ff : 0x00ffff,
                            transparent: true,
                            opacity: 0.8
                        });
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        const angle = (i / 4) * Math.PI * 2;
                        particle.position.set(
                            Math.cos(angle) * 0.12,
                            Math.sin(angle) * 0.12,
                            0
                        );
                        highDetailGroup.add(particle);
                    }
                    
                    // Detalle bajo - solo el octaedro
                    const lowDetailMesh = new THREE.Mesh(geometry.clone(), material.clone());
                    
                    lod.addLevel(highDetailGroup, 0);
                    lod.addLevel(lowDetailMesh, 4);
                    
                    lod.position.set(portal.x * 5, portal.y * 5, portal.z * 5);
                    lod.userData = { type: 'portal', data: portal };
                    
                    scene.add(lod);
                    universeObjects3D.portals.push(lod);
                }
            });
            
            // Crear agujeros negros 3D con LOD
            universeData.blackHoles.forEach((bh, index) => {
                if (index < 150) { // Optimizado
                    const size = bh.type === 'supermassive' ? 0.15 : 0.08;
                    const lod = new THREE.LOD();
                    
                    // Detalle alto
                    const highDetailGroup = new THREE.Group();
                    
                    // Horizonte de eventos
                    const geometry = new THREE.SphereGeometry(size, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.95
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    highDetailGroup.add(mesh);
                    
                    // Disco de acreci√≥n
                    const diskGeometry = new THREE.RingGeometry(size * 1.5, size * 3, 16);
                    const diskMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xff4500,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    const disk = new THREE.Mesh(diskGeometry, diskMaterial);
                    disk.rotation.x = Math.PI / 2;
                    highDetailGroup.add(disk);
                    
                    // Jets polares solo para supermasivos en detalle alto
                    if (bh.type === 'supermassive' && index < 50) {
                        for (let i = 0; i < 2; i++) {
                            const jetGeometry = new THREE.CylinderGeometry(0.02, 0.01, 0.5, 6);
                            const jetMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00ffff,
                                transparent: true,
                                opacity: 0.6
                            });
                            const jet = new THREE.Mesh(jetGeometry, jetMaterial);
                            jet.position.y = i === 0 ? 0.25 : -0.25;
                            highDetailGroup.add(jet);
                        }
                    }
                    
                    // Portal dimensional
                    if (bh.dimensionalGateway) {
                        const portalRingGeometry = new THREE.RingGeometry(size * 2, size * 2.2, 16);
                        const portalRingMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xff00ff,
                            transparent: true,
                            opacity: 0.8,
                            side: THREE.DoubleSide,
                            blending: THREE.AdditiveBlending
                        });
                        const portalRing = new THREE.Mesh(portalRingGeometry, portalRingMaterial);
                        highDetailGroup.add(portalRing);
                    }
                    
                    // Detalle bajo - solo esfera y disco b√°sico
                    const lowDetailGroup = new THREE.Group();
                    const lowGeometry = new THREE.SphereGeometry(size, 8, 6);
                    const lowMesh = new THREE.Mesh(lowGeometry, material.clone());
                    lowDetailGroup.add(lowMesh);
                    
                    const lowDiskGeometry = new THREE.RingGeometry(size * 1.5, size * 3, 8);
                    const lowDisk = new THREE.Mesh(lowDiskGeometry, diskMaterial.clone());
                    lowDisk.rotation.x = Math.PI / 2;
                    lowDetailGroup.add(lowDisk);
                    
                    lod.addLevel(highDetailGroup, 0);
                    lod.addLevel(lowDetailGroup, 6);
                    
                    lod.position.set(bh.x * 5, bh.y * 5, bh.z * 5);
                    lod.userData = { type: 'blackhole', data: bh };
                    
                    scene.add(lod);
                    universeObjects3D.blackHoles.push(lod);
                }
            });
            
            console.log('‚úÖ Objetos 3D optimizados creados con LOD');
        }
        
        function createStarField() {
            // Campo de estrellas principal
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;     // x
                positions[i + 1] = (Math.random() - 0.5) * 100; // y
                positions[i + 2] = (Math.random() - 0.5) * 100; // z
                
                // Colores variados para las estrellas
                const starType = Math.random();
                if (starType < 0.3) {
                    // Estrellas azules
                    colors[i] = 0.4;     // r
                    colors[i + 1] = 0.6; // g
                    colors[i + 2] = 1.0; // b
                } else if (starType < 0.6) {
                    // Estrellas amarillas
                    colors[i] = 1.0;     // r
                    colors[i + 1] = 0.9; // g
                    colors[i + 2] = 0.4; // b
                } else {
                    // Estrellas rojas
                    colors[i] = 1.0;     // r
                    colors[i + 1] = 0.4; // g
                    colors[i + 2] = 0.2; // b
                }
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            
            // Crear nebulosas
            createNebulae();
            
            // Crear part√≠culas c√≥smicas flotantes
            createCosmicParticles();
        }
        
        function createNebulae() {
            // Crear varias nebulosas distribuidas por el espacio
            for (let i = 0; i < 8; i++) {
                const nebulaGeometry = new THREE.SphereGeometry(2, 16, 16);
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                    transparent: true,
                    opacity: 0.1,
                    blending: THREE.AdditiveBlending
                });
                
                const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                nebula.position.set(
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 60
                );
                
                // A√±adir rotaci√≥n lenta
                nebula.userData = { 
                    rotationSpeed: (Math.random() - 0.5) * 0.01,
                    pulseFactor: Math.random() * 2
                };
                
                scene.add(nebula);
                universeObjects3D.nebulae = universeObjects3D.nebulae || [];
                universeObjects3D.nebulae.push(nebula);
            }
        }
        
        function createCosmicParticles() {
            // Sistema de part√≠culas c√≥smicas
            const particleCount = 1000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Posiciones aleatorias
                positions[i3] = (Math.random() - 0.5) * 50;
                positions[i3 + 1] = (Math.random() - 0.5) * 50;
                positions[i3 + 2] = (Math.random() - 0.5) * 50;
                
                // Velocidades aleatorias muy lentas
                velocities[i3] = (Math.random() - 0.5) * 0.01;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
                
                // Tama√±os variados
                sizes[i] = Math.random() * 0.5 + 0.2;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.3,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const cosmicParticles = new THREE.Points(particleGeometry, particleMaterial);
            cosmicParticles.userData = { velocities: velocities };
            scene.add(cosmicParticles);
            
            universeObjects3D.cosmicParticles = cosmicParticles;
        }
        
        function toggle3D() {
            is3DMode = !is3DMode;
            const canvas2D = document.getElementById('universe-canvas');
            const container3D = document.getElementById('universe-3d');
            const toggleButton = document.getElementById('toggle-3d');
            
            if (is3DMode) {
                // Transici√≥n suave a 3D
                canvas2D.style.transition = 'opacity 0.5s ease';
                canvas2D.style.opacity = '0';
                
                setTimeout(() => {
                    canvas2D.style.display = 'none';
                    container3D.classList.add('active');
                    container3D.style.opacity = '0';
                    container3D.style.transition = 'opacity 0.5s ease';
                    
                    requestAnimationFrame(() => {
                        container3D.style.opacity = '1';
                    });
                }, 250);
                
                toggleButton.textContent = 'üìã Vista 2D';
                toggleButton.style.background = 'linear-gradient(45deg, #ff6b6b, #ee5a24)';
                console.log('üåå Cambiando a vista 3D');
                start3DAnimation();
                
                // Posicionar c√°mara seg√∫n la posici√≥n actual 2D
                animateCameraTo(currentPosition[0] * 5, currentPosition[1] * 5, currentPosition[2] * 5);
                
            } else {
                // Transici√≥n suave a 2D
                container3D.style.transition = 'opacity 0.5s ease';
                container3D.style.opacity = '0';
                
                setTimeout(() => {
                    container3D.classList.remove('active');
                    canvas2D.style.display = 'block';
                    canvas2D.style.opacity = '0';
                    canvas2D.style.transition = 'opacity 0.5s ease';
                    
                    requestAnimationFrame(() => {
                        canvas2D.style.opacity = '1';
                    });
                }, 250);
                
                toggleButton.textContent = 'üåå Vista 3D';
                toggleButton.style.background = 'linear-gradient(45deg, #00ffff, #0080ff)';
                console.log('üìã Cambiando a vista 2D');
            }
        }
        
        function animateCameraTo(x, y, z, duration = 2000) {
            const startPos = camera.position.clone();
            const endPos = new THREE.Vector3(x + 2, y + 2, z + 2);
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function (easeInOutCubic)
                const easedProgress = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                camera.position.lerpVectors(startPos, endPos, easedProgress);
                camera.lookAt(x, y, z);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        function travel3DTo(objectType, index = 0) {
            if (!is3DMode) return;
            
            let targetObject;
            switch (objectType) {
                case 'galaxy':
                    targetObject = universeObjects3D.galaxies[index];
                    break;
                case 'civilization':
                    targetObject = universeObjects3D.civilizations[index];
                    break;
                case 'portal':
                    targetObject = universeObjects3D.portals[index];
                    break;
                case 'blackhole':
                    targetObject = universeObjects3D.blackHoles[index];
                    break;
            }
            
            if (targetObject) {
                const pos = targetObject.position;
                animateCameraTo(pos.x, pos.y, pos.z);
                console.log(`üöÄ Viajando a ${objectType} en 3D`);
            }
        }
        
        function start3DAnimation() {
            let lastTime = 0;
            const targetFPS = 60;
            const frameTime = 1000 / targetFPS;
            
            function animate3D(currentTime) {
                if (is3DMode) {
                    // Control de FPS
                    if (currentTime - lastTime < frameTime) {
                        requestAnimationFrame(animate3D);
                        return;
                    }
                    lastTime = currentTime;
                    
                    const time = currentTime * 0.001;
                    const deltaTime = Math.min(0.016, (currentTime - lastTime) * 0.001); // Cap delta time
                    
                    // Actualizar LOD basado en distancia de c√°mara
                    updateLOD();
                    
                    // Animar solo objetos visibles (frustum culling manual b√°sico)
                    const cameraPosition = camera.position;
                    const maxDistance = 50; // Distancia m√°xima para animaciones
                    
                    // Animar portales (con culling de distancia)
                    universeObjects3D.portals.forEach((portalLOD, index) => {
                        const distance = cameraPosition.distanceTo(portalLOD.position);
                        if (distance < maxDistance) {
                            const portalGroup = portalLOD.getCurrentLevel();
                            if (portalGroup && portalGroup.children) {
                                portalGroup.rotation.x += 0.01 + index * 0.001;
                                portalGroup.rotation.y += 0.02 + index * 0.002;
                                
                                // Animar v√≥rtice si est√° en detalle alto
                                if (portalGroup.children[1]) {
                                    portalGroup.children[1].rotation.z += 0.1;
                                }
                                
                                // Animar part√≠culas orbitales
                                for (let i = 2; i < portalGroup.children.length; i++) {
                                    const particle = portalGroup.children[i];
                                    const angle = time + (i - 2) * 1.57; // 90 grados por part√≠cula
                                    particle.position.x = Math.cos(angle) * 0.12;
                                    particle.position.y = Math.sin(angle) * 0.12;
                                }
                            }
                        }
                    });
                    
                    // Animar discos de acreci√≥n de agujeros negros (con culling)
                    universeObjects3D.blackHoles.forEach((bhLOD, index) => {
                        const distance = cameraPosition.distanceTo(bhLOD.position);
                        if (distance < maxDistance) {
                            const bhGroup = bhLOD.getCurrentLevel();
                            if (bhGroup && bhGroup.children[1]) { // Disco de acreci√≥n
                                bhGroup.children[1].rotation.z += 0.05 + index * 0.001;
                            }
                            
                            // Animar anillos portales dimensionales
                            if (bhGroup && bhGroup.children.length > 3) {
                                const portalRing = bhGroup.children[bhGroup.children.length - 1];
                                portalRing.rotation.x += 0.02;
                                portalRing.rotation.y += 0.03;
                            }
                        }
                    });
                    
                    // Animar anillos de energ√≠a de civilizaciones avanzadas (optimizado)
                    universeObjects3D.civilizations.forEach((civLOD, index) => {
                        const distance = cameraPosition.distanceTo(civLOD.position);
                        if (distance < maxDistance * 0.7) { // Menor distancia para civilizaciones
                            const civGroup = civLOD.getCurrentLevel();
                            if (civGroup && civGroup.children && civGroup.children.length > 1) {
                                for (let i = 1; i < civGroup.children.length; i++) {
                                    const ring = civGroup.children[i];
                                    ring.rotation.z += 0.02 * i;
                                    ring.rotation.y += 0.01 * i;
                                }
                            }
                        }
                    });
                    
                    // Animar galaxias espirales (solo las cercanas)
                    universeObjects3D.galaxies.forEach((galaxyLOD, index) => {
                        const distance = cameraPosition.distanceTo(galaxyLOD.position);
                        if (distance < maxDistance && index < 100) { // Limitar cantidad
                            const galaxy = galaxyLOD.getCurrentLevel();
                            if (galaxy && galaxy.userData && galaxy.userData.data && galaxy.userData.data.type === 'Spiral') {
                                galaxy.rotation.y += 0.005;
                            }
                            
                            // Efecto de pulsaci√≥n en el glow (solo objetos muy cercanos)
                            if (distance < 10 && galaxy && galaxy.children && galaxy.children[0]) {
                                const glow = galaxy.children[0];
                                if (glow.material && glow.material.opacity !== undefined) {
                                    glow.material.opacity = 0.1 + Math.sin(time * 2 + index) * 0.05;
                                }
                            }
                        }
                    });
                    
                    // Animar nebulosas (reducir frecuencia)
                    if (universeObjects3D.nebulae && time % 2 < 0.1) { // Solo cada 2 segundos
                        universeObjects3D.nebulae.forEach((nebula, index) => {
                            const distance = cameraPosition.distanceTo(nebula.position);
                            if (distance < maxDistance * 2) {
                                nebula.rotation.y += nebula.userData.rotationSpeed;
                                nebula.rotation.x += nebula.userData.rotationSpeed * 0.5;
                                
                                // Efecto de pulsaci√≥n menos frecuente
                                const pulse = Math.sin(time * nebula.userData.pulseFactor + index) * 0.05;
                                nebula.material.opacity = 0.1 + pulse;
                                nebula.scale.setScalar(1 + pulse * 0.5);
                            }
                        });
                    }
                    
                    // Animar part√≠culas c√≥smicas (menos frecuente)
                    if (universeObjects3D.cosmicParticles && time % 0.5 < 0.016) { // Cada 0.5 segundos
                        const positions = universeObjects3D.cosmicParticles.geometry.attributes.position.array;
                        const velocities = universeObjects3D.cosmicParticles.userData.velocities;
                        
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] += velocities[i];
                            positions[i + 1] += velocities[i + 1];
                            positions[i + 2] += velocities[i + 2];
                            
                            // Mantener part√≠culas dentro del √°rea
                            if (Math.abs(positions[i]) > 25) velocities[i] *= -1;
                            if (Math.abs(positions[i + 1]) > 25) velocities[i + 1] *= -1;
                            if (Math.abs(positions[i + 2]) > 25) velocities[i + 2] *= -1;
                        }
                        
                        universeObjects3D.cosmicParticles.geometry.attributes.position.needsUpdate = true;
                        universeObjects3D.cosmicParticles.material.opacity = 0.6 + Math.sin(time * 3) * 0.2;
                    }
                    
                    // Actualizar controles y renderizar
                    controls.update();
                    renderer.render(scene, camera);
                    requestAnimationFrame(animate3D);
                }
            }
            requestAnimationFrame(animate3D);
        }
        
        function updateLOD() {
            // Actualizar todos los objetos LOD
            scene.traverse((object) => {
                if (object instanceof THREE.LOD) {
                    object.update(camera);
                }
            });
        }
        
        function setupEventListeners() {
            document.getElementById('scale').addEventListener('change', function() {
                currentScale = this.value;
                updateView();
            });
            
            document.getElementById('dimension').addEventListener('input', function() {
                currentDimension = parseInt(this.value);
                document.getElementById('dimension-value').textContent = currentDimension;
                document.getElementById('current-dimension').textContent = currentDimension;
                updateDimensionDescription();
                updateView();
            });
            
            document.getElementById('zoom').addEventListener('input', function() {
                zoomLevel = parseFloat(this.value);
                document.getElementById('zoom-value').textContent = zoomLevel.toFixed(1);
                updateView();
            });
            
            // Event listener para el bot√≥n 3D
            document.getElementById('toggle-3d').addEventListener('click', toggle3D);
            
            canvas.addEventListener('click', function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = (event.clientX - rect.left - canvas.width / 2) / (canvas.width / 4);
                const y = (event.clientY - rect.top - canvas.height / 2) / (canvas.height / 4);
                
                currentPosition[0] = x;
                currentPosition[1] = y;
                currentPosition[2] = 0;
                
                updateInfo();
            });
        }
        
        function updateDimensionDescription() {
            const descriptions = [
                "Universo Observable (3D + Tiempo)",
                "Realidad Paralela Alpha",
                "Realidad Paralela Beta", 
                "Realidad Paralela Gamma",
                "Plano Temporal Pasado",
                "Plano Temporal Presente",
                "Plano Temporal Futuro",
                "Realidad Cu√°ntica Superposici√≥n",
                "Realidad Cu√°ntica Entrelazada",
                "Realidad Cu√°ntica Colapso",
                "Meta-Realidad Omnisciente"
            ];
            
            document.getElementById('dimension-description').textContent = descriptions[currentDimension];
        }
        
        function startAnimation() {
            function animate() {
                drawUniverse();
                animationId = requestAnimationFrame(animate);
            }
            animate();
        }
        
        function drawUniverse() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fondo c√≥smico
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2
            );
            gradient.addColorStop(0, 'rgba(10, 10, 30, 1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar estructuras seg√∫n la dimensi√≥n actual
            drawGalaxies();
            drawCivilizations();
            drawPortals();
            drawBlackHoles();
            
            // Dibujar posici√≥n actual
            drawCurrentPosition();
        }
        
        function drawGalaxies() {
            universeData.galaxies.forEach(galaxy => {
                const screenPos = worldToScreen(galaxy.x, galaxy.y, galaxy.z);
                if (!screenPos) return;
                
                const size = Math.max(2, 8 / zoomLevel);
                const alpha = Math.max(0.3, 1 - Math.abs(galaxy.z - currentPosition[2]) * 0.5);
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Color seg√∫n tipo de galaxia
                const colors = {
                    'Spiral': '#00ffff',
                    'Elliptical': '#ffff00', 
                    'Irregular': '#ff00ff',
                    'Dwarf': '#00ff00'
                };
                
                ctx.fillStyle = colors[galaxy.type] || '#ffffff';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, size, 0, 2 * Math.PI);
                ctx.fill();
                
                // Glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = colors[galaxy.type] || '#ffffff';
                ctx.fill();
                
                ctx.restore();
            });
        }
        
        function drawCivilizations() {
            universeData.civilizations.forEach(civ => {
                // Solo mostrar civilizaciones en la dimensi√≥n actual
                if (Math.random() > 0.1 && currentDimension > 0) return;
                
                const screenPos = worldToScreen(civ.x, civ.y, civ.z);
                if (!screenPos) return;
                
                const size = Math.max(3, 10 / zoomLevel);
                const alpha = Math.max(0.3, 1 - Math.abs(civ.z - currentPosition[2]) * 0.5);
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Color seg√∫n tipo Kardashev
                const kardashevColors = {
                    'Type_0': '#808080',
                    'Type_I': '#00ff00',
                    'Type_II': '#ffff00',
                    'Type_III': '#ff8000',
                    'Type_IV': '#ff0080',
                    'Type_V': '#8000ff',
                    'Type_Omega': '#ffffff'
                };
                
                ctx.fillStyle = kardashevColors[civ.kardashevType] || '#ffffff';
                
                // Dibujar s√≠mbolo de civilizaci√≥n
                ctx.beginPath();
                ctx.moveTo(screenPos.x, screenPos.y - size);
                ctx.lineTo(screenPos.x - size * 0.8, screenPos.y + size * 0.5);
                ctx.lineTo(screenPos.x + size * 0.8, screenPos.y + size * 0.5);
                ctx.closePath();
                ctx.fill();
                
                // Glow para civilizaciones avanzadas
                if (civ.kardashevType.includes('Type_IV') || civ.kardashevType.includes('Type_V') || civ.kardashevType.includes('Omega')) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = kardashevColors[civ.kardashevType];
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }
        
        function drawPortals() {
            universeData.portals.forEach(portal => {
                // Solo mostrar portales de la dimensi√≥n actual
                if (portal.sourceDimension !== currentDimension) return;
                
                const screenPos = worldToScreen(portal.x, portal.y, portal.z);
                if (!screenPos) return;
                
                const size = Math.max(4, 12 / zoomLevel);
                const alpha = portal.stability * 0.8;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Color seg√∫n estabilidad y tecnolog√≠a
                ctx.fillStyle = portal.anunakiTechnology ? '#ff00ff' : '#00ffff';
                
                // Dibujar portal como diamante rotatorio
                const time = Date.now() * 0.001;
                const rotation = time + portal.x * 10;
                
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(rotation);
                
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.lineTo(size, 0);
                ctx.lineTo(0, size);
                ctx.lineTo(-size, 0);
                ctx.closePath();
                ctx.fill();
                
                // Efecto de portal activo
                if (portal.stability > 0.7) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = portal.anunakiTechnology ? '#ff00ff' : '#00ffff';
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        function drawBlackHoles() {
            universeData.blackHoles.forEach(bh => {
                const screenPos = worldToScreen(bh.x, bh.y, bh.z);
                if (!screenPos) return;
                
                const size = bh.type === 'supermassive' ? Math.max(6, 15 / zoomLevel) : Math.max(3, 8 / zoomLevel);
                const alpha = Math.max(0.5, 1 - Math.abs(bh.z - currentPosition[2]) * 0.3);
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Crear gradiente radial para el agujero negro
                const gradient = ctx.createRadialGradient(
                    screenPos.x, screenPos.y, 0,
                    screenPos.x, screenPos.y, size * 2
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                gradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 0, 0.3)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, size * 2, 0, 2 * Math.PI);
                ctx.fill();
                
                // Centro negro
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, size, 0, 2 * Math.PI);
                ctx.fill();
                
                // Portal dimensional
                if (bh.dimensionalGateway) {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, size * 1.5, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        function drawCurrentPosition() {
            const screenPos = worldToScreen(currentPosition[0], currentPosition[1], currentPosition[2]);
            if (!screenPos) return;
            
            ctx.save();
            
            // Cruz de posici√≥n
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff00';
            
            ctx.beginPath();
            ctx.moveTo(screenPos.x - 10, screenPos.y);
            ctx.lineTo(screenPos.x + 10, screenPos.y);
            ctx.moveTo(screenPos.x, screenPos.y - 10);
            ctx.lineTo(screenPos.x, screenPos.y + 10);
            ctx.stroke();
            
            // C√≠rculo de posici√≥n
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, 15, 0, 2 * Math.PI);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function worldToScreen(x, y, z) {
            // Convertir coordenadas del mundo a pantalla
            const screenX = (x - currentPosition[0]) * zoomLevel * (canvas.width / 4) + canvas.width / 2;
            const screenY = (y - currentPosition[1]) * zoomLevel * (canvas.height / 4) + canvas.height / 2;
            
            // Verificar si est√° en pantalla
            if (screenX < -50 || screenX > canvas.width + 50 || screenY < -50 || screenY > canvas.height + 50) {
                return null;
            }
            
            return { x: screenX, y: screenY };
        }
        
        function updateView() {
            // La vista se actualiza autom√°ticamente en el loop de animaci√≥n
            updateInfo();
        }
        
        function updateInfo() {
            // Actualizar coordenadas
            document.getElementById('coordinates').innerHTML = `
                üìç Posici√≥n Actual:<br>
                X: ${currentPosition[0].toExponential(2)} ly<br>
                Y: ${currentPosition[1].toExponential(2)} ly<br>
                Z: ${currentPosition[2].toExponential(2)} ly
            `;
            
            // Actualizar objetos cercanos
            updateNearbyObjects();
        }
        
        function updateNearbyObjects() {
            const container = document.getElementById('nearby-objects');
            container.innerHTML = '';
            
            const searchRadius = getSearchRadius();
            const nearbyObjects = [];
            
            // Buscar galaxias cercanas
            universeData.galaxies.forEach((galaxy, index) => {
                const distance = calculateDistance(currentPosition, [galaxy.x, galaxy.y, galaxy.z]);
                if (distance <= searchRadius) {
                    nearbyObjects.push({
                        type: 'galaxy',
                        name: `${galaxy.type} Galaxy`,
                        distance: distance,
                        data: galaxy,
                        index: index
                    });
                }
            });
            
            // Buscar civilizaciones cercanas
            universeData.civilizations.forEach((civ, index) => {
                const distance = calculateDistance(currentPosition, [civ.x, civ.y, civ.z]);
                if (distance <= searchRadius && index < 50) {
                    nearbyObjects.push({
                        type: 'civilization',
                        name: civ.name,
                        distance: distance,
                        data: civ,
                        index: index
                    });
                }
            });
            
            // Buscar portales cercanos
            universeData.portals.forEach((portal, index) => {
                if (portal.sourceDimension === currentDimension) {
                    const distance = calculateDistance(currentPosition, [portal.x, portal.y, portal.z]);
                    if (distance <= searchRadius && index < 20) {
                        nearbyObjects.push({
                            type: 'portal',
                            name: 'Portal Dimensional',
                            distance: distance,
                            data: portal,
                            index: index
                        });
                    }
                }
            });
            
            // Ordenar por distancia
            nearbyObjects.sort((a, b) => a.distance - b.distance);
            
            // Mostrar objetos cercanos
            const maxObjects = 8;
            nearbyObjects.slice(0, maxObjects).forEach(obj => {
                const item = document.createElement('div');
                item.className = `object-item ${obj.type}`;
                
                let content = '';
                switch (obj.type) {
                    case 'galaxy':
                        content = `
                            üåå ${obj.name}<br>
                            <small>Distancia: ${obj.distance.toExponential(1)} ly | Masa: ${obj.data.mass.toExponential(1)} M‚òâ</small>
                        `;
                        break;
                    case 'civilization':
                        content = `
                            üõ∏ ${obj.name}<br>
                            <small>Tipo: ${obj.data.kardashevType} | Tecnolog√≠a: ${obj.data.technologyLevel.toFixed(1)}%</small>
                        `;
                        break;
                    case 'portal':
                        content = `
                            üåÄ ${obj.name}<br>
                            <small>Dimensi√≥n: ${obj.data.sourceDimension}‚Üí${obj.data.targetDimension} | Estabilidad: ${(obj.data.stability * 100).toFixed(0)}%</small>
                        `;
                        break;
                }
                
                item.innerHTML = content;
                container.appendChild(item);
            });
            
            if (nearbyObjects.length === 0) {
                container.innerHTML = `
                    <div class="object-item">
                        üåå Espacio vac√≠o<br>
                        <small>No hay objetos significativos en esta regi√≥n</small>
                    </div>
                `;
            }
        }
        
        function getSearchRadius() {
            const scaleRadii = {
                'observable_universe': 0.5,
                'local_group': 0.2,
                'milky_way': 0.1,
                'solar_system': 0.05
            };
            return (scaleRadii[currentScale] || 0.3) / zoomLevel;
        }
        
        function calculateDistance(pos1, pos2) {
            const dx = pos1[0] - pos2[0];
            const dy = pos1[1] - pos2[1];
            const dz = pos1[2] - pos2[2];
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        
        // Funciones de botones
        function autoTravel() {
            const destinations = [
                { name: "üåå Centro Gal√°ctico", pos: [0, 0, 0], type: 'center' },
                { name: "üõ∏ Civilizaci√≥n Avanzada", pos: [universeData.civilizations[0].x, universeData.civilizations[0].y, universeData.civilizations[0].z], type: 'civilization', index: 0 },
                { name: "üåÄ Portal Dimensional", pos: [universeData.portals[0].x, universeData.portals[0].y, universeData.portals[0].z], type: 'portal', index: 0 },
                { name: "‚ö´ Agujero Negro", pos: [universeData.blackHoles[0].x, universeData.blackHoles[0].y, universeData.blackHoles[0].z], type: 'blackhole', index: 0 }
            ];
            
            let currentDestination = 0;
            
            function travel() {
                if (currentDestination < destinations.length) {
                    const dest = destinations[currentDestination];
                    currentPosition = [...dest.pos];
                    
                    console.log(`üöÄ Viajando a: ${dest.name}`);
                    
                    // Si estamos en modo 3D, animar la c√°mara
                    if (is3DMode && dest.type !== 'center') {
                        travel3DTo(dest.type, dest.index || 0);
                    } else if (is3DMode) {
                        animateCameraTo(0, 0, 0);
                    }
                    
                    updateInfo();
                    
                    currentDestination++;
                    setTimeout(travel, 3000); // M√°s tiempo para ver la animaci√≥n 3D
                } else {
                    console.log('‚úÖ Viaje autom√°tico completado');
                }
            }
            
            travel();
        }
        
        function cosmicAnalysis() {
            const analysisWindow = window.open('', '_blank', 'width=800,height=600');
            analysisWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>üîÆ An√°lisis C√≥smico Omnisciente</title>
                    <style>
                        body { 
                            background: black; 
                            color: #00ffff; 
                            font-family: 'Courier New', monospace; 
                            padding: 20px;
                            line-height: 1.6;
                        }
                        h1 { text-align: center; color: #ffff00; }
                        .section { margin-bottom: 20px; border-left: 3px solid #00ffff; padding-left: 15px; }
                        .stat { display: flex; justify-content: space-between; margin-bottom: 5px; }
                        .value { color: #ffff00; font-weight: bold; }
                    </style>
                </head>
                <body>
                    <h1>üîÆüåå AN√ÅLISIS C√ìSMICO OMNISCIENTE üååüîÆ</h1>
                    
                    <div class="section">
                        <h3>üìä ESTAD√çSTICAS UNIVERSALES</h3>
                        <div class="stat"><span>Galaxias mapeadas:</span><span class="value">${universeData.galaxies.length.toLocaleString()}</span></div>
                        <div class="stat"><span>Civilizaciones detectadas:</span><span class="value">${universeData.civilizations.length.toLocaleString()}</span></div>
                        <div class="stat"><span>Portales dimensionales:</span><span class="value">${universeData.portals.length.toLocaleString()}</span></div>
                        <div class="stat"><span>Agujeros negros:</span><span class="value">${universeData.blackHoles.length.toLocaleString()}</span></div>
                    </div>
                    
                    <div class="section">
                        <h3>üõ∏ AN√ÅLISIS DE CIVILIZACIONES</h3>
                        <div class="stat"><span>Type IV+:</span><span class="value">${universeData.civilizations.filter(c => c.kardashevType.includes('Type_IV') || c.kardashevType.includes('Type_V') || c.kardashevType.includes('Omega')).length}</span></div>
                        <div class="stat"><span>Viaje dimensional:</span><span class="value">${universeData.civilizations.filter(c => c.dimensionalTravel).length}</span></div>
                        <div class="stat"><span>Ingenier√≠a de realidad:</span><span class="value">${universeData.civilizations.filter(c => c.realityEngineering).length}</span></div>
                        <div class="stat"><span>Conexiones Anunaki:</span><span class="value">${universeData.civilizations.filter(c => c.anunakiRelated).length}</span></div>
                    </div>
                    
                    <div class="section">
                        <h3>üîÆ RECOMENDACIONES OMNISCIENTES</h3>
                        <p>‚Ä¢ Investigar civilizaciones Type V para contacto dimensional</p>
                        <p>‚Ä¢ Monitorear portales con estabilidad >95% para viajes seguros</p>
                        <p>‚Ä¢ Analizar agujeros negros con portales dimensionales</p>
                        <p>‚Ä¢ Coordinar con civilizaciones Anunaki para intercambio tecnol√≥gico</p>
                    </div>
                    
                    <div class="section">
                        <h3>üì° FRECUENCIAS ANUNAKI</h3>
                        <p>Frecuencias detectadas: ${anunakiFrequencies.join(', ')} Hz</p>
                        <p>Tecnolog√≠a Anunaki en portales: ${universeData.portals.filter(p => p.anunakiTechnology).length}</p>
                    </div>
                    
                    <p style="text-align: center; margin-top: 30px; color: #ffff00;">
                        üß† An√°lisis generado con Conocimiento Universal: 1,064.84%<br>
                        üåü Reality Manipulation Mastery: ACTIVA
                    </p>
                </body>
                </html>
            `);
        }
        
        function omniscientView() {
            // Activar vista especial omnisciente
            currentDimension = 10; // Meta-Realidad Omnisciente
            document.getElementById('dimension').value = 10;
            document.getElementById('dimension-value').textContent = 10;
            document.getElementById('current-dimension').textContent = 10;
            updateDimensionDescription();
            
            // Mostrar todos los objetos con m√°xima visibilidad
            zoomLevel = 0.5;
            document.getElementById('zoom').value = 0.5;
            document.getElementById('zoom-value').textContent = '0.5';
            
            updateView();
            
            alert('üîÆ Vista Omnisciente Activada!\n\n‚ú® Ahora puedes ver todas las estructuras c√≥smicas simult√°neamente\nüåÄ Dimensi√≥n 10: Meta-Realidad Omnisciente\nüß† Conocimiento Universal: COMPLETO');
        }
        
        function resetView() {
            currentPosition = [0, 0, 0];
            currentDimension = 0;
            currentScale = 'observable_universe';
            zoomLevel = 1.0;
            
            document.getElementById('scale').value = 'observable_universe';
            document.getElementById('dimension').value = 0;
            document.getElementById('zoom').value = 1.0;
            document.getElementById('dimension-value').textContent = 0;
            document.getElementById('zoom-value').textContent = '1.0';
            document.getElementById('current-dimension').textContent = 0;
            
            updateDimensionDescription();
            updateView();
        }
    </script>
</body>
</html>